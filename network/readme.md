# Part 1. Network
Made by. 김영주 김지섭 김지훈 조형준 하태린

## [1.1. OSI 7 layers와 TCP/IP 4 layers](#OSI-7-layers와-TCPIP-4-layers-답변)
#### 💡 OSI 7계층이란?
#### 💡 tcp/ip 프로토콜을 스택 4계층

## [1.2. HTTP와 HTTPS](#HTTP와-HTTPS-답변)
#### 💡 GET 방식과 POST 방식의 차이는 무엇인가요?
#### 💡 RESTful이란 무엇이며, 이것에 대해 아는대로 설명해보세요.

## [1.3. TCP와 UDP](#TCP와-UDP-답변)
#### 💡 TCP와 UDP의 차이는 무엇인가요?
#### 💡 3 way & 4 way handshake에 대해서 설명해주세요.
#### 💡 UDP 통신이란?

## [1.4. WEB](#WEB-답변)
#### 💡 브라우저에 특정 url을 입력하면, 어떤 과정이 일어나는가?
#### 💡 Blocking/Non-blocking & Synchronous/Asynchronous

## [1.5. 네트워크 장비](#네트워크 장비)
#### 💡 허브, 스위치, 라우터의 차이점

<br/><br/>

## 1.1. OSI 7 layers와 TCPIP 4 layers 답변

#### 💡 OSI 7계층이란?

OSI 7 계층은 국제 표준 기관 ISO가 통신 접속부터 완료까지의 과정을 총 7단계로 정의한 국제 통신 표준 모델입니다.

OSI 7 계층은 Physical, Data Link, Network, Transport, Session, Presentation, Application으로 구성되어 있습니다.

- 물리계층은 데이터를 전기신호로 바꿔주는 계층입니다.
- 데이터링크 계층은 MAC 주소를 가지고 통신하는 계층입니다. 오류검출과 흐름제어를 통해 데이터가 안전하게 도달하도록 합니다.
- 네트워크 계층은 IP주소를 이용해서 최적의 경로를 제공하는 역할입니다.
- 전송계층은 데이터 전송을 위한 논리적인 연결을 하는 역할을 합니다.
- 표현계층은 서로 다른 Application들이 data를 이해할 수 있도록 도와주는 계층입니다. 데이타의 압축, 암호화, JPEG포맷 등을 수행합니다.

 #### 💡 tcp/ip 프로토콜을 스택 4계층 이란?
 
- tcp/ip 프로토콜을 스택 4계층
    - 1계층: 물리, 데이터링크 계층
         - 1계층은 이더넷(LAN, WAN으로 연결된 네트워크 기술, 프로토콜) 프로토콜을 사용한다. 물리계층은 전기신호를 받으면 허브 또는 스위치에 신호를 전달한다.
         - 물리 계층에서는 전기신호를 목적지에 정확히 전달하는 게 목적이다. 
    - 2계층: 네트워크 계층, IP 계층
         - 2계층에서는 논리적 주소인 IP가 쓰입니다. IP는 네트워크 주소+호스트 주소로 되어있다.
         - 경로 검색을 해주는 계층이며, 데이터를 전송할 때마다 거쳐야 할 경로를 선택해주지만, 경로가 일정하지 않다.
         - 데이터 전송 중에 경로 상 문제가 발생할 때 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있습니다. 따라서 IP 계층은 오류 발생에 대한 대비가 되어있지 않은 프로토콜입니다.
     - 3계층: 트랜스포트 계층, TCP/UDP (전송) 계층
         - 데이터의 실제 송수신을 담당함
         - UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성잇는 데이터 전송을 담당한다.
         - TCP는 데이터 전송 시, IP 프로토콜이 기반이다. (IP는 문제 해결에 문제가 있는데 TCP가 신뢰?) → IP의 문제를 해결해주는 것이 TCP인 것이다. 데이터의 순서가 올바르게 전송 갔는지 확인해주며 대화를 주고받는 방식이며, 이처럼 확인 절차를 걸치며 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이 TCP이다.
     - 4계층: 애플리케이션 계층
         - 서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층이다 

출처 : https://gyoogle.dev/blog/interview/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html
       https://another-light.tistory.com/30 


## 1.2. HTTP와 HTTPS 답변

#### 💡 GET 방식과 POST 방식의 차이는 무엇인가요?

먼저, HTTP 패킷의 구조는 크게 헤더와 바디로 나뉩니다.  
그 중 헤더에는 HTTP 메서드 방식인 GET과 POST 중 무엇을 썼는지의 정보가 담겨 있습니다.  
두 방식 모두 서버에 요청을 하는 request 메서드이지만,  
* GET은 데이터를 조회하기 위해서 사용하는 방식으로 데이터를 헤더에 추가하여 전송하며, URL에 데이터가 노출되기 때문에 패스워드 같은 중요한 데이터를 포함하면 안되는 방식이며,
* POST는 데이터를 추가 또는 수정하기 위해서 사용하는 방식으로 데이터를 바디에 추가하여 전송하는 방식이며, URL에 데이터가 직접적으로 노출되지 않기 때문에 GET 방식보다는 비교적 안전하다고 할 수 있습니다.

#### 💡 RESTful이란 무엇이며, 이것에 대해 아는대로 설명해보세요.

- HTTP URL을 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현하는 REST의 원리를 따르는 시스템을 의미합니다. REST를 사용했다 하여 모두가 RESTful 한 것은 아니며, REST API 설계 규칙을 올바르게 지킨 시스템들을 RESTful하다 라고 말할 수 있습니다.

- 추가) REST의 특징
    1. Server-Client(서버-클라이언트 구조)
    2. Stateless(무상태)
    3. Cacheable(캐시 처리 가능)
    4. Layered System(계층화)
    5. Uniform Interface(인터페이스 일관성)
    
- REST API 설계 예시
    1. URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다.
    2. 마지막에 슬래시 (/)를 포함하지 않는다.
    3. 언더바 대신 하이폰을 사용한다.
    4. 파일확장자는 URI에 포함하지 않는다.
    5. 행위를 포함하지 않는다.
   
출처 : https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80


## 1.3. TCP와 UDP 답변

#### 💡 TCP와 UDP의 차이는 무엇인가요?

- UDP VS TCP
    
    OSI 7계층에서 4계층인 전송 계층의 프토코콜인 UDP, TCP 프로토콜
    
    - UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)
        - 비연결형 프로토콜, 비신뢰성 통신 제공을 한다.
        - 전송 방식이 너무 단순해서 서비스의 신뢰성이 낮다.
        - 데이터 그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락 시키기도 한다.
        - UPD는 일반적으로 오류의 검사와 수정이 필요 없는 프로그램에서 수행할 것으로 가정한다.
        - 비용이 TCP에 비하여 저렴하다.
        - UPD 프로토콜은 대표적으로 DNS 서버에서 사용한다. (DNS 서버는 도메인을 물으면 IP 를 알려주는 서버이다.)
    - TCP (Transmission Control Protocol, 전송제어 프로토콜)
        - TCP는 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 통신을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 한다.
        - UDP 로는 이를 만족 시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP 이다.
        - UDP에 비해 안전하지만 속도가 느리며 비용이 더 든다.
        - TCP 에서 연결 설정(connection establishment)는 3 way handshake를 통해 행해진다.
        - TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다. (참고로 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미한다.)
        - TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

#### 💡 3 way & 4 way handshake에 대해서 설명해주세요.

* 3 way handshake
1. 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence : x)  
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (sequence : y, ACK : x + 1)  
3. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄  
    * 이렇게 3번의 통신이 완료되면 연결이 성립된다. (3번이라 3 way handshake인 것)

* 4 way handshake
1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다   
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)   
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.  
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)  
- 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)  
- TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)  
    * 이렇게 4번의 통신이 완료되면 연결이 해제된다


#### 💡 UDP 통신이란?

- UDP 통신
    - User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜이다.
    - 비연결형, 신뢰성 없는 전송 프로토콜이다.
    - 데이터그램 단위로 쪼개면서 전송을 해야하기 때문에 전송 계층이다.
    - Transport layer에서 사용하는 프로토콜.
    
- UDP는 왜 사용할까?
    - UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.
    - 주로 실시간 방송과 온라인 게임에서 사용된다. 네트워크 환경이 안 좋을때, 끊기는 현상을 생각하면 된다.
    
- DNS(Domain Name Service)에서 UDP를 사용하는 이유**
    - Request의 양이 작음 -> UDP Request에 담길 수 있다.
    - 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)
    - Request에 대한 손실은 Application Layer에서 제어가 가능하다.
    - DNS : port 53번
    - But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다.
    
- UDP Header

![image](https://user-images.githubusercontent.com/75787789/179667531-8593c701-bd63-4f81-877d-87d070b8bc84.png)

    - Source port : 시작 포트
    - Destination port : 도착지 포트
    - Length : 길이
    - *Checksum* : 오류 검출
        - 중복 검사의 한 형태로, 오류 정정을 통해 공간이나 시간 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.
    이렇게 간단하므로, TCP 보다 용량이 가볍고 송신 속도가 빠르게 작동됨.
    그러나 확인 응답을 못하므로, TCP보다 신뢰도가 떨어짐.
    UDP는 비연결성, TCP는 연결성으로 정의할 수 있음.

- DNS과 UDP 통신 프로토콜을 사용

DNS는 데이터를 교환하는 경우다.
이때, TCP를 사용하게 되면, 데이터를 송신할 때까지 세션 확립을 위한 처리를 하고, 송신한 데이터가 수신되었는지 점검하는 과정이 필요하므로, Protocol overhead가 UDP에 비해서 큼.

출처 : https://gyoogle.dev/blog/computer-science/network/UDP.html#dns%E1%84%80%E1%85%AA-udp-%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC

## 1.4. WEB 답변

#### 💡 브라우저에 특정 url을 입력하면, 어떤 과정이 일어나는가?

1. 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력  
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색  
3. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달  
4. 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성, 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송  
5. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환  
6. 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색  
7. 검색된 웹 페이지 데이터는 또다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성, 이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송  
8. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환  
9. 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있음


#### 💡 브라우저에 특정 url을 입력하면, 어떤 과정이 일어나는가?
- Blocking/Non-blocking & Synchronous/Asynchronous

![image](https://user-images.githubusercontent.com/75787789/179669500-7d4dcfea-9721-46b7-8caf-4def2b9dc6f2.png)

## **Blocking/Non-blocking**

블럭/논블럭은 간단히 말해서 `호출된 함수`가 `호출한 함수`에게 제어권을 건네주는 유무의 차이라고 볼 수 있다.

함수 A, B가 있고, A 안에서 B를 호출했다고 가정해보자. 
이때 호출한 함수는 A고, 호출된 함수는 B가 된다. 
현재 B가 호출되면서 B는 자신의 일을 진행해야 한다. 
(제어권이 B에게 주어진 상황)

- **Blocking** : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.
- **Non-blocking** : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다. A는 B를 기다리면서도 다른 일을 진행할 수 있다.

즉, 호출된 함수에서 일을 시작할 때 바로 제어권을 리턴해주느냐, 할 일을 마치고 리턴해주느냐에 따라 블럭과 논블럭으로 나누어진다고 볼 수 있다.

## **Synchronous/Asynchronous**

동기/비동기는 일을 수행 중인 `동시성`에 주목하자

아까처럼 함수 A와 B라고 똑같이 생각했을 때, B의 수행 결과나 종료 상태를 A가 신경쓰고 있는 유무의 차이라고 생각하면 된다.

- **Synchronous** : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.
- **Asynchronous** : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (Callback)

즉, 호출된 함수(B)를 호출한 함수(A)가 신경쓰는지, 호출된 함수(B) 스스로 신경쓰는지를 동기/비동기라고 생각하면 된다.

비동기는 호출시 Callback을 전달하여 작업의 완료 여부를 호출한 함수에게 답하게 된다. (Callback이 오기 전까지 호출한 함수는 신경쓰지 않고 다른 일을 할 수 있음)

출처 : https://gyoogle.dev/blog/computer-science/network/Blocking%20&%20Non-Blocking.html
       https://gyoogle.dev/blog/computer-science/network/Blocking,Non-blocking%20&%20Synchronous,Asynchronous.html


## 1.5. 네트워크 장비

#### 💡 허브, 스위치, 라우터의 차이점
- 허브 

    허브는 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키고, 여러 대의 디바이스를 연결해 네트워크를 만들어주는 장비입니다.
    포트는 허브에 따라 다양하며, 1개의 포트에 한 대의 디바이스가 할당됩니다.

    허브로 연결된 네트워크에서 하나의 디바이스에서 전송된 데이터 프레임을 허브로 **연결된 모든 디바이스에게 데이터를** **전부 전송하는 플러딩이 발생**합니다. 결과적으로 **충돌이 많이 발생**하여 하나의 허브에는 많은 디바이스를 연결할 수 없습니다. 동일한 이유로 보안성 또한 떨어집니다.

    허브는 크게 멀티포트와 리피터 두가지 기능으로 많이 사용됩니다.

    멀티포트는 한번에 많은 디바이스를 연결할 수 있는 기능으로, 만약 허브가 없다면 디바이스는 두 대만 연결 가능합니다.

    리피터 같은 경우에는 전기적인 신호를 증폭시켜 들어온 데이터를 재전송 한다는 의미를 가지고 있습니다. 또한, 리피터 기능을 사용하면 LAN의 최대 전송거리도 연장되고, 접속할 수 있는 장비의 수도 많아집니다. **허브는 IP를 할당하는 기능이 없고, 단순히 포트를 늘려주는 기능을 가집니다**.

    허브는 단순한 분배 중계기에 불과하여 **연결되는 디바이스 수에 따라 데이터 전송 대역이 분리**됩니다.

    ex. 10Mbps를 제공하는 이더넷에 8포트 허브로 PC를 연결시킬 경우 **각 PC는 1.25Mbps의 대역폭만을 사용**하게 되는 것입니다.

- 스위치

    스위치는 자신에게 연결된 디바이스들의 MAC 주소와 포트가 기록된 **MAC 주소 테이블**을 가지고 있습니다. 따라서 프레임이 자신에게 오면 그 것의 목적지가 어디인지 파악하여 그 디바이스에게 프레임을 보내기 때문에 트래픽이 훨씬 효율적입니다.

    또한, **스위치는 데이터의 전송 에러 등을 복구**해주는 기능들을 가집니다.

    서버의 경우 사용자들이 많기 때문에 허브 보다 스위치를 사용하는 것이 좋습니다.

    다만, 스위치는 자신의 테이블에 없는 목적지를 가진 패킷이 오면 해당 패킷을 연결된 모든 장치에 포워딩하는데, 이 경우에는 허브와 동일한 동작을 하는 것입니다.

    ex. 10Mbps를 제공하는 이더넷에 스위치로 PC를 연결시킬 경우  하나의 장치에 데이터를 전송하기 때문에 각 PC는 10Mbps로 **대역폭이 유지**됩니다.
    
- 라우터

    LAN을 연결시켜주는 장치로써 정보를 주고 받을 때 **송신정보 (패킷)에 담긴 수신처의 주소를 읽고**,

    가장 적절한 통신경로를 이용하여 다른 통신망으로 전송하는 장치입니다.

    서로 다른 프로토콜로 운영하는 통신망에서 정보를 전송하기 위해 경로를 설정하는 역할을 제공하는 핵심적인 통신 장비입니다.
    라우터는 IP 주소 등 L3에 있는 주소를 참조하여 목적지와 연결되는 포트로 패킷을 전송합니다.

    서브넷 마스크가 **다른 IP 주소를 가진 장비간 통신을 하기 위해서는 반드시 L3 장비를 거쳐야만 합니다.**


</br>

</br>
